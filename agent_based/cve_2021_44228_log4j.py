#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# License: GNU General Public License v2
#
# Author: thl-cmk[at]outlook[dot]com
# URL   : https://thl-cmk.hopto.org
# Date  : 2021-12-17
#
# Plugin for the CVE-2021-44228-log4j scanner from logpresso
# https://github.com/logpresso/CVE-2021-44228-Scanner
#
# 2021-12-20: made the plugin more stable on missing scanner output
# 2021-12-22: fixed unexpected value for check_levels
# 2021-12-27: added files_skipped and errors and lower levels to files/directories
# 2022-01-03: made parse function more robust (files_potential_vulnerable = int(line[1]) if line[1].isdigit() else None)
# 2022-01-07: changed output of values to make it "sortable"
#             added warn on missing agent output
#             fixed run_time missing on service info (THX to doc[at]snowheaven[dot]de)
# 2022-01-11: added inventory report section
# 2022-01-12: modified logpresso report time format to ISO861
# 2022-01-14: added params to inventory sections
# 2022-01-17: added check plugin with CVE id as item
# 2022-01-18: extended inventory report for additional log4j CVEs
#             removed status_data inventory
# 2022-01-21: reworked report inventory plugin and per cve check
# 2022-01-30: added additional CVEs for Log4j 1
#             added WAR/CRIT based on CVSS score (0.1, 5.5)
#             changed defaults for WARN/CRIT of affected files form (1, 1) to (None, None)
#             added Description/Comment to service details
# 2022-02-05: fixed missing comment in CVE data (THX to doc[at]snowheaven[dot]de)
#

# sample agent output
# <<<cve_2021_44228_log4j:sep(0);cached(1639746030,600)>>>
# Logpresso CVE-2021-44228 Vulnerability Scanner 2.0.0 (2021-12-17)
# Scanning directory: / (without /dev, /run, /dev/shm, /run/lock, /sys/fs/cgroup, /run/user/1003)
#
# Scanned 20865 directories and 209109 files
# Found 0 vulnerable files
# Found 0 potentially vulnerable files
# Found 0 mitigated files
# Completed in 3.30 seconds
#
#
# sample string_table
# [
#  ['Logpresso CVE-2021-44228 Vulnerability Scanner 2.0.0 (2021-12-17)'],
#  ['Scanning directory: / (without /dev, /run, /dev/shm, /run/lock, /sys/fs/cgroup, /run/user/1003'],
#  ['Scanned 20865 directories and 209109 files'],
#  ['Found 0 vulnerable files'],
#  ['Found 0 potentially vulnerable files'],
#  ['Found 0 mitigated files'],
#  ['Completed in 5.07 seconds']
# ]
#
#

import json
from typing import Optional, Dict, List
from dataclasses import dataclass
from cmk.base.plugins.agent_based.agent_based_api.v1.type_defs import (
    DiscoveryResult,
    StringTable,
    CheckResult,
    InventoryResult,
)

from cmk.base.plugins.agent_based.agent_based_api.v1 import (
    register,
    Service,
    State,
    check_levels,
    render,
    Result,
    TableRow,
)


@dataclass
class CVE:
    files_vulnerable: int
    files_potential_vulnerable: int
    files_mitigated: int
    files: List[str]


@dataclass
class CVE_2021_44228_log4j:
    scanner_version: Optional[str]
    files_vulnerable: Optional[int]
    files_potential_vulnerable: Optional[int]
    files_mitigated: Optional[int]
    files_scanned: Optional[int]
    files_skipped: Optional[int]
    directories_scanned: Optional[int]
    run_time: Optional[float]
    errors: Optional[int]
    last_run: Optional[str]
    scan_options: Optional[str]
    script_version: Optional[str]
    bakery_version: Optional[str]
    details: str
    cves: Dict[str, CVE]


_cves = [
    'CVE-2019-17571', 'CVE-2020-9488', 'CVE-2021-4104', 'CVE-2022-23302', 'CVE-2022-23305', 'CVE-2022-23307',
    'CVE-2021-44832', 'CVE-2021-45105', 'CVE-2021-45046', 'CVE-2021-44228', 'CVE-2017-5645',
    'CVE-2021-42550',
]

_log4_cves = {
    'Log4j 1': {
        'CVE-2019-17571': {
            'fixed': [],
            'excluded': [],
            'affected': '1.2.17',
            'cvss_score': 7.5,
            'description': 'CVE-2019-17571 is a high severity issue targeting the SocketServer. Log4j includes a '
                           'SocketServer that accepts serialized log events and deserializes them without verifying '
                           'whether the objects are allowed or not. This can provide an attack vector that can be '
                           'expoited.',
            'comment': 'Apache Log4j 1.2 reached end of life in August 2015. Migrate to Log4j 2',
        },
        'CVE-2020-9488': {
            'fixed': [],
            'excluded': [],
            'affected': '1.2.17',
            'cvss_score': 4.3,
            'description': 'CVE-2020-9488 is a moderate severity issue with the SMTPAppender. Improper validation of '
                           'certificate with host mismatch in Apache Log4j SMTP appender. This could allow an SMTPS '
                           'connection to be intercepted by a man-in-the-middle attack which could leak any log '
                           'messages sent through that appender.',
            'comment': 'Apache Log4j 1.2 reached end of life in August 2015. Migrate to Log4j 2',
        },
        'CVE-2021-4104': {
            'fixed': [],
            'excluded': [],
            'affected': '1.2.17',
            'cvss_score': 7.5,
            'description': 'CVE-2021-4104 is a high severity deserialization vulnerability in JMSAppender. JMSAppender '
                           'uses JNDI in an unprotected manner allowing any application using the JMSAppender to be '
                           'vulnerable if it is configured to reference an untrusted site or if the site referenced '
                           'can be accesseed by the attacker. For example, the attacker can cause remote code '
                           'execution by manipulating the data in the LDAP store.',
            'comment': 'Apache Log4j 1.2 reached end of life in August 2015. Migrate to Log4j 2',
        },
        'CVE-2022-23302': {
            'fixed': [],
            'excluded': [],
            'affected': '1.2.17',
            'cvss_score': 6.0,
            'description': 'CVE-2022-23302 is a high severity deserialization vulnerability in JMSSink. JMSSink uses '
                           'JNDI in an unprotected manner allowing any application using the JMSSink to be vulnerable '
                           'if it is configured to reference an untrusted site or if the site referenced can be '
                           'accesseed by the attacker. For example, the attacker can cause remote code execution by '
                           'manipulating the data in the LDAP store.',
            'comment': 'Apache Log4j 1.2 reached end of life in August 2015. Migrate to Log4j 2',
        },
        'CVE-2022-23305': {
            'fixed': [],
            'excluded': [],
            'affected': '1.2.17',
            'cvss_score': 6.8,
            'description': 'CVE-2022-23305 is a high serverity SQL injection flaw in JDBCAppender that allows the '
                           'data being logged to modify the behavior of the component. By design, the JDBCAppender in '
                           'Log4j 1.2.x accepts an SQL statement as a configuration parameter where the values to be '
                           'inserted are converters from PatternLayout. The message converter, %m, is likely to always '
                           'be included. This allows attackers to manipulate the SQL by entering crafted strings into '
                           'input fields or headers of an application that are logged allowing unintended SQL queries '
                           'to be executed.',
            'comment': 'Apache Log4j 1.2 reached end of life in August 2015. Migrate to Log4j 2',
        },
        'CVE-2022-23307': {
            'fixed': [],
            'excluded': [],
            'affected': '1.2.17',
            'cvss_score': 10.0,
            'description': 'CVE-2022-23307 is a critical severity against the chainsaw component in Log4j 1.x. This is '
                           'the same issue corrected in CVE-2020-9493 fixed in Chainsaw 2.1.0 but Chainsaw was '
                           'included as part of Log4j 1.2.x.',
            'comment': 'Apache Log4j 1.2 reached end of life in August 2015. Migrate to Log4j 2',
        },

    },
    'Log4j 2': {
        'CVE-2021-44832': {
            'fixed': ['2.3.2', '2.12.4', '2.17.1'],
            'excluded': ['2.3.2', '2.12.4'],
            'affected': '2.17.0',
            'cvss_score': 6.6,
            'description': 'Apache Log4j2 versions 2.0-beta7 through 2.17.0 (excluding security fix releases 2.3.2 '
                           'and 2.12.4) are vulnerable to a remote code execution (RCE) attack where an attacker with '
                           'permission to modify the logging configuration file can construct a malicious configuration'
                           ' using a JDBC Appender with a data source referencing a JNDI URI which can execute remote '
                           'code. This issue is fixed by limiting JNDI data source names to the java protocol in Log4j2'
                           ' versions 2.17.1, 2.12.4, and 2.3.2.',
            'comment': '',
        },
        'CVE-2021-45105': {
            'fixed': ['2.3.1', '2.12.3', '2.17.0'],
            'excluded': ['2.12.3'],
            'affected': '2.16.0',
            'cvss_score': 5.9,
            'description': 'Apache Log4j2 versions 2.0-alpha1 through 2.16.0, excluding 2.12.3, did not protect from '
                           'uncontrolled recursion from self-referential lookups. When the logging configuration uses '
                           'a non-default Pattern Layout with a Context Lookup (for example, $${ctx:loginId}), '
                           'attackers with control over Thread Context Map (MDC) input data can craft malicious input '
                           'data that contains a recursive lookup, resulting in a StackOverflowError that will '
                           'terminate the process. This is also known as a DOS (Denial of Service) attack.',
            'comment': '',
        },
        'CVE-2021-45046': {
            'fixed': ['2.3.1', '2.12.3', '2.17.0'],
            'excluded': ['2.12.2'],
            'affected': '2.15.0',
            'cvss_score': 9.0,
            'description': 'It was found that the fix to address CVE-2021-44228 in Apache Log4j 2.15.0 was incomplete '
                           'in certain non-default configurations. When the logging configuration uses a non-default '
                           'Pattern Layout with a Context Lookup (for example, $${ctx:loginId}), attackers with control'
                           ' over Thread Context Map (MDC) input data can craft malicious input data using a JNDI '
                           'Lookup pattern, resulting in an information leak and remote code execution in some '
                           'environments and local code execution in all environments; remote code execution has been '
                           'demonstrated on MacOS, Fedora, Arch Linux, and Alpine Linux.',
            'comment': '',
        },
        'CVE-2021-44228': {
            'fixed': ['2.3.1', '2.12.3', '2.17.0'],
            'excluded': [],
            'affected': '2.14.1',
            'cvss_score': 10.0,
            'description': 'In Apache Log4j2 versions up to and including 2.14.1 (excluding security releases 2.3.1, '
                           '2.12.2 and 2.12.3), the JNDI features used in configurations, log messages, and parameters '
                           'do not protect against attacker-controlled LDAP and other JNDI related endpoints. An '
                           'attacker who can control log messages or log message parameters can execute arbitrary code '
                           'loaded from LDAP servers when message lookup substitution is enabled.',
            'comment': '',
        },
        'CVE-2020-9488': {
            'fixed': ['2.12.3', '2.13.2'],
            'excluded': [],
            'affected': '2.13.1',
            'description': 'Improper validation of certificate with host mismatch in Log4j2 SMTP appender. This could '
                           'allow an SMTPS connection to be intercepted by a man-in-the-middle attack which could leak '
                           'any log messages sent through that appender. The reported issue was caused by an error in '
                           'SslConfiguration. Any element using SslConfiguration in the Log4j Configuration is also '
                           'affected by this issue. This includes HttpAppender, SocketAppender, and SyslogAppender. '
                           'Usages of SslConfiguration that are configured via system properties are not affected.',
            'cvss_score': 3.7,
            'comment': '',
        },
        'CVE-2017-5645': {
            'fixed': ['2.8.2'],
            'excluded': [],
            'affected': '2.8.1',
            'cvss_score': 7.5,
            'description': 'When using the TCP socket server or UDP socket server to receive serialized log events '
                           'from another application, a specially crafted binary payload can be sent that, when '
                           'deserialized, can execute arbitrary code.',
            'comment': '',
        },
    },
    'Logback': {
        'CVE-2021-42550': {
            'fixed': ['1.2.9'],
            'excluded': [],
            'affected': '1.2.7',
            'cvss_score': 8.5,
            'description': 'In logback version 1.2.7 and prior versions, an attacker with the required privileges to '
                           'edit configurations files could craft a malicious configuration allowing to execute '
                           'arbitrary code loaded from LDAP servers.',
            'comment': '',
        },
    },
}


def _parse_cves(cves: Dict[str, CVE], line: str) -> Dict[str, CVE]:
    split_line = line.split(' ')
    cve = split_line[2]

    if cve not in cves.keys():
        cves[cve] = CVE(
            files_vulnerable=0,
            files_potential_vulnerable=0,
            files_mitigated=0,
            files=[]
        )

    if split_line[0] == '[*]':
        cves[cve].files_vulnerable += 1
    elif split_line[0] == '[?]':
        cves[cve].files_potential_vulnerable += 1
    if split_line[-1] == '(mitigated)':
        cves[cve].files_mitigated += 1
    cves[cve].files.append(line)

    return cves


def parse_cve_2021_44228_log4j(string_table: StringTable) -> CVE_2021_44228_log4j:
    details = ''
    last_run = string_table[0][0]
    scanner_version = None
    files_vulnerable = None
    files_potential_vulnerable = None
    files_mitigated = None
    files_scanned = None
    directories_scanned = None
    files_skipped = 0
    errors = 0
    run_time = None
    scan_options = None
    script_version = None
    bakery_version = None
    cves = {}

    for line in string_table:
        line = str(line[0])
        details += f'\n{line}'

        if line.startswith('Logpresso CVE-2021-44228 Vulnerability Scanner'):
            scanner_version = line[47:]
        elif line.startswith('SCAN OPTIONS: '):
            scan_options = line[14:]  # cut 'SCAN OPTIONS: '
        elif line.startswith('SCRIPT VERSION: '):
            script_version = line[16:]  # cut 'SCRIPT VERSION: '
        elif line.startswith('BAKERY VERSION: '):
            bakery_version = line[16:]  # cut 'BAKERY VERSION: '
        elif line.startswith('Scanned '):
            line = line.split(' ')
            directories_scanned = int(line[1]) if line[1].isdigit() else None
            files_scanned = int(line[4]) if line[4].isdigit() else None
        elif line.find(' potentially vulnerable files') != -1:
            line = line.split(' ')
            files_potential_vulnerable = int(line[1]) if line[1].isdigit() else None
        elif line.find(' vulnerable files') != -1:
            line = line.split(' ')
            files_vulnerable = int(line[1]) if line[1].isdigit() else None
        elif line.find(' mitigated files') != -1:
            line = line.split(' ')
            files_mitigated = int(line[1]) if line[1].isdigit() else None
        elif line.startswith('Completed in '):
            line = line.split(' ')
            run_time = float(line[2])
        elif line.startswith('Skipping '):
            files_skipped += 1
        elif line.lower().startswith('error: '):
            errors += 1
        elif line[:3] in ['[*]', '[?]']:
            cves = _parse_cves(cves, line)

    return CVE_2021_44228_log4j(
        scanner_version=scanner_version,
        files_vulnerable=files_vulnerable,
        files_potential_vulnerable=files_potential_vulnerable,
        files_mitigated=files_mitigated,
        files_scanned=files_scanned,
        files_skipped=files_skipped,
        directories_scanned=directories_scanned,
        run_time=run_time,
        errors=errors,
        last_run=last_run,
        scan_options=scan_options,
        script_version=script_version,
        bakery_version=bakery_version,
        details=details,
        cves=cves,
    )


#
# sample section
# CVE_2021_44228_log4j(
#  files_vulnerable=0,
#  files_potential_vulnerable=0,
#  files_mitigated=0,
#  files_scanned=209109,
#  directories_scanned=20865,
#  run_time=5.07,
#  details='\nLogpresso CVE-2021-44228 Vulnerability Scanner 2.0.0 (2021-12-17)
#           \nScanning directory: / (without /dev, /run, /dev/shm, /run/lock, /sys/fs/cgroup, /run/user/1003)
#           \nScanned 20865 directories and 209109 files\n Found 0 vulnerable files
#           \nFound 0 potentially vulnerable files
#           \nFound 0 mitigated files
#           \nCompleted in 5.07 seconds')
#
#

# #########################################################################################################
#
# Check plugin for log4j CVE summary/main
#
# #########################################################################################################


def discovery_cve_2021_44228_log4j(section: CVE_2021_44228_log4j) -> DiscoveryResult:
    yield Service()


def check_cve_2021_44228_log4j(params, section: CVE_2021_44228_log4j) -> CheckResult:
    items_on_info = params['items_on_info']
    ignore_missing_output = params['ignore_missing_output']

    for value, label, metric, notice_only, levels_upper, levels_lower in [
        (section.files_vulnerable, 'Files vulnerable', 'files_vulnerable', False, params['files_vulnerable'], None),
        (section.files_potential_vulnerable, 'Files potentially vulnerable', 'files_potential_vulnerable', False, params['files_potential_vulnerable'], None),
        (section.files_mitigated, 'Files mitigated', 'files_mitigated', True, params['files_mitigated'], None),
        (section.files_skipped, 'Files skipped', 'files_skipped', True, params['files_skipped'], None),
        (section.errors, 'Errors', 'errors', True, params['errors'], None),
        (section.files_scanned, 'Files scanned', 'files_scanned', True, params['files_scanned'].get('upper'), params['files_scanned'].get('lower')),
        (section.directories_scanned, 'Directories scanned', 'directories_scanned', True, params['directories_scanned'].get('upper'), params['directories_scanned'].get('lower')),
        (section.run_time, 'Run time', 'run_time', True, params['run_time'], None),
        (section.last_run, 'Last run', 'last_run', True, None, None),
        (section.scanner_version, 'Scanner version', 'scanner_version', True, None, None),
        (section.script_version, 'Script version', 'script_version', True, None, None),
        (section.bakery_version, 'Bakery version', 'bakery_version', True, None, None),
        (section.scan_options, 'Scan options', 'scan_options', True, None, None),
    ]:
        if str(value).isdigit():
            yield from check_levels(
                value=value,
                label=label,
                metric_name=metric,
                levels_upper=levels_upper,
                levels_lower=levels_lower,
                notice_only=False if metric in items_on_info else notice_only,
                render_func=lambda v: str(v),
            )
        elif type(value) == float:
            yield from check_levels(
                value=value,
                label=label,
                metric_name=metric,
                levels_upper=levels_upper,
                levels_lower=levels_lower,
                notice_only=False if metric in items_on_info else notice_only,
                render_func=render.timespan,
            )
        elif type(value) == str:
            if metric in items_on_info:
                yield Result(state=State.OK, summary=f'{label}: {value}')
            else:
                yield Result(state=State.OK, notice=f'{label}: {value}')

        elif metric not in ignore_missing_output:
            yield Result(state=State(params['state_missing_output']), notice=f'{label} is missing from agent output')

    yield Result(state=State.OK, notice='\nRaw output of the script and the scanner:')
    yield Result(state=State.OK, notice=section.details)


register.agent_section(
    name="cve_2021_44228_log4j",
    parse_function=parse_cve_2021_44228_log4j,
)

register.check_plugin(
    name='cve_2021_44228_log4j',
    service_name='CVE-2021-44228-log4j',
    discovery_function=discovery_cve_2021_44228_log4j,
    check_function=check_cve_2021_44228_log4j,
    check_default_parameters={
        'files_vulnerable': (1, 1),
        'files_potential_vulnerable': (1, 1),
        'files_mitigated': (1, None),
        'files_scanned': {
            'lower': (None, None),
            'upper': (None, None),
        },
        'files_scanned_lower': (None, None),
        'files_skipped': (1, None),
        'errors': (None, 1),
        'directories_scanned': {
            'lower': (None, None),
            'upper': (None, None),
        },
        'directories_scanned_lower': (None, None),
        'run_time': (None, None),
        'items_on_info': [
            'files_vulnerable',
            'files_potential_vulnerable',
        ],
        'state_missing_output': 1,
        'ignore_missing_output': [
            'bakery_version',
            'script_version',
            'errors',
            'files_skipped',
        ],
    },
    check_ruleset_name='cve_2021_44228_log4j'
)


# #########################################################################################################
#
# Inventory for CVE scanner for log4j (CVE-2021-44228-log4j) summary
#
# #########################################################################################################


def inventory_inv_cve_2021_44228_log4j(params, section: CVE_2021_44228_log4j) -> InventoryResult:
    if params.get('do_not_inv_summary'):
        return

    path = ['software', 'cve_2021_44228_log4j', 'summary']

    key_columns = {'index': '1'}
    inventory_columns = {}

    for key, value in [
        ('scanner_version', section.scanner_version),
        ('scan_options', section.scan_options),
        ('script_version', section.script_version),
        ('bakery_version', section.bakery_version),
        ('files_vulnerable', section.files_vulnerable),
        ('files_potential_vulnerable', section.files_potential_vulnerable),
        ('files_mitigated', section.files_mitigated),
        ('files_scanned', section.files_scanned),
        ('files_skipped', section.files_skipped),
        ('directories_scanned', section.directories_scanned),
        ('run_time', section.run_time),
        ('last_run', section.last_run),
        ('errors', section.errors),
    ]:
        if value is not None:
            inventory_columns.update({key: value})

    yield TableRow(
        path=path,
        key_columns=key_columns,
        inventory_columns=inventory_columns,
    )


register.inventory_plugin(
    name='inv_cve_2021_44228_log4j',
    sections=['cve_2021_44228_log4j'],
    inventory_function=inventory_inv_cve_2021_44228_log4j,
    inventory_ruleset_name='inventory_cve_2021_44228_log4j',
    inventory_default_parameters={
        'do_not_inv_summary': False
    },
)


# #########################################################################################################
#
# Inventory for CVE scanner for log4j (CVE-2021-44228-log4j) report
#
# #########################################################################################################

def _get_affected(version: str, affected: str) -> bool:
    _version = version.split('.')
    _affected = affected.split('.')

    if int(_version[0]) < int(_affected[0]):
        return True
    elif int(_version[0]) > int(_affected[0]):
        return False
    elif int(_version[1]) < int(_affected[1]):
        return True
    elif int(_version[1]) > int(_affected[1]):
        return False
    elif int(_version[2]) <= int(_affected[2]):
        return True

    return False


def _add_log4j_cves(version: str, product: str) -> Dict[str, str]:
    additional_cves = {}

    try:
        cves = _log4_cves[product]
    except KeyError:
        return {}

    for cve in cves.keys():
        if version == 'N/A':
            additional_cves[cve] = 'unknown, missing version'
        elif (_get_affected(version, cves[cve]['affected']) is True) and (version not in cves[cve]['excluded']):
            additional_cves[cve] = f'Affected'  # , fixed in: {", ".join(cves[cve]["fixed"])}
        else:
            additional_cves[cve] = 'not affected'

    return additional_cves


def parse_inv_cve_2021_44228_log4j_report(string_table: StringTable):

    def _get_ISO861_time(time_str: str) -> str:
        return f'{time_str[:10]}T{time_str[11:22]}:{time_str[22:]}'  # 2022-01-11T20:06:41+01:00

    try:
        section = json.loads(string_table[0][0])
    except (json.decoder.JSONDecodeError, IndexError):
        section = None

    section.update({
        'affected': {
        }
    })

    for file in section.get('files', []):
        for report in file['reports']:
            _version = report['version']
            _product = report['product']
            report['time'] = _get_ISO861_time(report['detected_at'])  # 2022-01-11 20:06:41+0100, convert to ISO8601
            report.pop('detected_at')
            report['fixed'] = str(report['fixed'])
            report.update(_add_log4j_cves(_version, _product))

            file_name = file['path']
            file_entry = file.get('entry')

            to_append = f'{_product}, {_version}, {file_name}'
            if file_entry:
                to_append += f', ({file_entry})'

            for key in report.keys():
                if key.startswith('CVE-'):
                    if report[key].lower().startswith('affected') or report[key].lower().startswith('unknown'):
                        if section['affected'].get(key):
                            section['affected'][key]['files'].append(to_append)
                        else:
                            section['affected'].update({
                                key: {
                                    'cve': _log4_cves[_product][key],
                                    'files': [to_append]
                                }})

    for error in section.get('errors', []):
        error['time'] = _get_ISO861_time(error['created_at'])  # 2022-01-11 20:06:41+0100, convert to ISO8601
        error.pop('created_at')
        error['status'] = 'ERROR'

    return section


register.agent_section(
    name="cve_2021_44228_log4j_report",
    parse_function=parse_inv_cve_2021_44228_log4j_report,
)


def inv_cve_2021_44228_log4j_report(params, section: Dict) -> InventoryResult:
    path = ['software', 'cve_2021_44228_log4j', 'report']
    index = 1

    for file in section.get('files', []):
        for report in file['reports']:
            key_columns = {'index': index}
            inventory_columns = {'path': file['path']}
            inventory_columns.update(report)

            yield TableRow(
                path=path,
                key_columns=key_columns,
                inventory_columns=inventory_columns,
            )
            index += 1

    if not params.get('do_not_inv_errors'):
        for error in section.get('errors', []):
            key_columns = {'index': index}
            inventory_columns = error

            yield TableRow(
                path=path,
                key_columns=key_columns,
                inventory_columns=inventory_columns,
            )
            index += 1


register.inventory_plugin(
    name='cve_2021_44228_log4j_report',
    inventory_function=inv_cve_2021_44228_log4j_report,
    inventory_ruleset_name='inventory_cve_2021_44228_log4j',
    inventory_default_parameters={
        'do_not_inv_errors': False,
    },
)


# #########################################################################################################
#
# Check plugin for log4j per CVE
#
# #########################################################################################################


def discovery_cve_2021_44228_log4j_cves(params, section: Dict) -> DiscoveryResult:
    if params['add_empty_cves']:
        for cve in _cves:
            yield Service(item=cve)
    else:
        for cve in section['affected'].keys():
            if len(section['affected'][cve]):
                yield Service(item=cve)


def check_cve_2021_44228_log4j_cves(item, params, section: Dict) -> CheckResult:
    try:
        cve = section['affected'][item]
    except KeyError:
        yield Result(state=State(params['state_not_found']), summary='Not found in agent data.')
        return

    yield from check_levels(
        value=len(cve.get('files', '')),
        label='Affected files',
        render_func=lambda v: str(v),
        levels_upper=params['files_affected'],
        metric_name='files_affected',
    )

    if cve['cve'].get('cvss_score'):
        yield from check_levels(
            value=cve['cve']['cvss_score'],
            label='CVSS Score',
            render_func=lambda v: str(v),
            levels_upper=params['cvss_score'] if cve.get('files') else None,
        )

    if cve['cve'].get('fixed'):
        yield Result(state=State.OK, summary=f'Fixed in: {", ".join(cve["cve"]["fixed"])}')
    else:
        yield Result(state=State.WARN, summary=f'not fixed')

    if cve['cve'].get('description'):
        yield Result(state=State.OK, notice=f'\n{cve["cve"]["description"]}')

    if cve['cve'].get('comment'):
        yield Result(state=State.OK, notice=f'\n{cve["cve"]["comment"]}')

    yield Result(state=State.OK, notice=f'\nlist of file affected by {item}:')
    if cve.get('files'):
        yield Result(state=State.OK, notice='\nProduct, Version, File')
        yield Result(state=State.OK, notice='\n'.join(cve['files']))
    else:
        yield Result(state=State.OK, notice='\nno affected files found')


register.check_plugin(
    name='cve_2021_44228_log4_cves',
    sections=['cve_2021_44228_log4j_report'],
    service_name='log4j %s',
    discovery_default_parameters={
        'add_empty_cves': False,
    },
    discovery_ruleset_name='discovery_cve_2021_44228_log4_cves',
    discovery_function=discovery_cve_2021_44228_log4j_cves,
    check_function=check_cve_2021_44228_log4j_cves,
    check_default_parameters={
        'files_affected': (None, None),
        'cvss_score': (0.1, 5.5),
        'state_not_found': 3,
    },
    check_ruleset_name='cve_2021_44228_log4_cves',
)

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# License: GNU General Public License v2
#
# Author: thl-cmk[at]outlook[dot]com
# URL   : https://thl-cmk.hopto.org
# Date  : 2021-12-17
#
# Plugin for the CVE-2021-44228-log4j scanner from logpresso
# https://github.com/logpresso/CVE-2021-44228-Scanner
#
# 2021-12-20: made the plugin more stable on missing scanner output
# 2021-12-22: fixed unexpected value for check_levels
# 2021-12-27: added files_skipped and errors and lower levels to files/directories
# 2022-01-03: made parse function more robust (files_potential_vulnerable = int(line[1]) if line[1].isdigit() else None)
# 2022-01-07: changed output of values to make it "sortable"
#             added warn on missing agent output
#             fixed run_time missing on service info (THX to doc[at]snowheaven[dot]de)
# 2022-01-11: added inventory report section
# 2022-01-12: modified logpresso report time format to ISO861
# 2022-01-14: added params to inventory sections
#

# sample agent output
# <<<cve_2021_44228_log4j:sep(0);cached(1639746030,600)>>>
# Logpresso CVE-2021-44228 Vulnerability Scanner 2.0.0 (2021-12-17)
# Scanning directory: / (without /dev, /run, /dev/shm, /run/lock, /sys/fs/cgroup, /run/user/1003)
#
# Scanned 20865 directories and 209109 files
# Found 0 vulnerable files
# Found 0 potentially vulnerable files
# Found 0 mitigated files
# Completed in 3.30 seconds
#
#
# sample string_table
# [
#  ['Logpresso CVE-2021-44228 Vulnerability Scanner 2.0.0 (2021-12-17)'],
#  ['Scanning directory: / (without /dev, /run, /dev/shm, /run/lock, /sys/fs/cgroup, /run/user/1003'],
#  ['Scanned 20865 directories and 209109 files'],
#  ['Found 0 vulnerable files'],
#  ['Found 0 potentially vulnerable files'],
#  ['Found 0 mitigated files'],
#  ['Completed in 5.07 seconds']
# ]
#
#

import json
from typing import Optional, Dict
from dataclasses import dataclass
from cmk.base.plugins.agent_based.agent_based_api.v1.type_defs import (
    DiscoveryResult,
    StringTable,
    CheckResult,
    InventoryResult,
)

from cmk.base.plugins.agent_based.agent_based_api.v1 import (
    register,
    Service,
    State,
    check_levels,
    render,
    Result,
    TableRow,
)


@dataclass
class CVE_2021_44228_log4j:
    scanner_version: Optional[str]
    files_vulnerable: Optional[int]
    files_potential_vulnerable: Optional[int]
    files_mitigated: Optional[int]
    files_scanned: Optional[int]
    files_skipped: Optional[int]
    directories_scanned: Optional[int]
    run_time: Optional[float]
    errors: Optional[int]
    last_run: Optional[str]
    scan_options: Optional[str]
    script_version: Optional[str]
    bakery_version: Optional[str]
    details: str


def parse_cve_2021_44228_log4j(string_table: StringTable) -> CVE_2021_44228_log4j:
    details = ''
    last_run = string_table[0][0]

    scanner_version = None
    files_vulnerable = None
    files_potential_vulnerable = None
    files_mitigated = None
    files_scanned = None
    directories_scanned = None
    files_skipped = 0
    errors = 0
    run_time = None
    scan_options = None
    script_version = None
    bakery_version = None

    for line in string_table:
        line = str(line[0])
        details += f'\n{line}'

        if line.startswith('Logpresso CVE-2021-44228 Vulnerability Scanner'):
            scanner_version = line[47:]
        elif line.startswith('SCAN OPTIONS: '):
            scan_options = line[14:]  # cut 'SCAN OPTIONS: '
        elif line.startswith('SCRIPT VERSION: '):
            script_version = line[16:]  # cut 'SCRIPT VERSION: '
        elif line.startswith('BAKERY VERSION: '):
            bakery_version = line[16:]  # cut 'BAKERY VERSION: '
        elif line.startswith('Scanned '):
            line = line.split(' ')
            directories_scanned = int(line[1]) if line[1].isdigit() else None
            files_scanned = int(line[4]) if line[4].isdigit() else None
        elif line.find(' potentially vulnerable files') != -1:
            line = line.split(' ')
            files_potential_vulnerable = int(line[1]) if line[1].isdigit() else None
        elif line.find(' vulnerable files') != -1:
            line = line.split(' ')
            files_vulnerable = int(line[1]) if line[1].isdigit() else None
        elif line.find(' mitigated files') != -1:
            line = line.split(' ')
            files_mitigated = int(line[1]) if line[1].isdigit() else None
        elif line.startswith('Completed in '):
            line = line.split(' ')
            run_time = float(line[2])
        elif line.startswith('Skipping '):
            files_skipped += 1
        elif line.lower().startswith('error: '):
            errors += 1

    return CVE_2021_44228_log4j(
        scanner_version=scanner_version,
        files_vulnerable=files_vulnerable,
        files_potential_vulnerable=files_potential_vulnerable,
        files_mitigated=files_mitigated,
        files_scanned=files_scanned,
        files_skipped=files_skipped,
        directories_scanned=directories_scanned,
        run_time=run_time,
        errors=errors,
        last_run=last_run,
        scan_options=scan_options,
        script_version=script_version,
        bakery_version=bakery_version,
        details=details,
    )


#
# sample section
# CVE_2021_44228_log4j(
#  files_vulnerable=0,
#  files_potential_vulnerable=0,
#  files_mitigated=0,
#  files_scanned=209109,
#  directories_scanned=20865,
#  run_time=5.07,
#  details='\nLogpresso CVE-2021-44228 Vulnerability Scanner 2.0.0 (2021-12-17)
#           \nScanning directory: / (without /dev, /run, /dev/shm, /run/lock, /sys/fs/cgroup, /run/user/1003)
#           \nScanned 20865 directories and 209109 files\n Found 0 vulnerable files
#           \nFound 0 potentially vulnerable files
#           \nFound 0 mitigated files
#           \nCompleted in 5.07 seconds')
#
#


def discovery_cve_2021_44228_log4j(section: CVE_2021_44228_log4j) -> DiscoveryResult:
    yield Service()


def check_cve_2021_44228_log4j(params, section: CVE_2021_44228_log4j) -> CheckResult:
    items_on_info = params['items_on_info']
    ignore_missing_output = params['ignore_missing_output']

    for value, label, metric, notice_only, levels_upper, levels_lower in [
        (section.files_vulnerable, 'Files vulnerable', 'files_vulnerable', False, params['files_vulnerable'], None),
        (section.files_potential_vulnerable, 'Files potentially vulnerable', 'files_potential_vulnerable', False, params['files_potential_vulnerable'], None),
        (section.files_mitigated, 'Files mitigated', 'files_mitigated', True, params['files_mitigated'], None),
        (section.files_skipped, 'Files skipped', 'files_skipped', True, params['files_skipped'], None),
        (section.errors, 'Errors', 'errors', True, params['errors'], None),
        (section.files_scanned, 'Files scanned', 'files_scanned', True, params['files_scanned'].get('upper'), params['files_scanned'].get('lower')),
        (section.directories_scanned, 'Directories scanned', 'directories_scanned', True, params['directories_scanned'].get('upper'), params['directories_scanned'].get('lower')),
        (section.run_time, 'Run time', 'run_time', True, params['run_time'], None),
        (section.last_run, 'Last run', 'last_run', True, None, None),
        (section.scanner_version, 'Scanner version', 'scanner_version', True, None, None),
        (section.script_version, 'Script version', 'script_version', True, None, None),
        (section.bakery_version, 'Bakery version', 'bakery_version', True, None, None),
        (section.scan_options, 'Scan options', 'scan_options', True, None, None),
    ]:
        if str(value).isdigit():
            yield from check_levels(
                value=value,
                label=label,
                metric_name=metric,
                levels_upper=levels_upper,
                levels_lower=levels_lower,
                notice_only=False if metric in items_on_info else notice_only,
                render_func=lambda v: str(v),
            )
        elif type(value) == float:
            yield from check_levels(
                value=value,
                label=label,
                metric_name=metric,
                levels_upper=levels_upper,
                levels_lower=levels_lower,
                notice_only=False if metric in items_on_info else notice_only,
                render_func=render.timespan,
            )
        elif type(value) == str:
            if metric in items_on_info:
                yield Result(state=State.OK, summary=f'{label}: {value}')
            else:
                yield Result(state=State.OK, notice=f'{label}: {value}')

        elif metric not in ignore_missing_output:
            yield Result(state=State(params['state_missing_output']), notice=f'{label} is missing from agent output')

    yield Result(state=State.OK, notice='\nRaw output of the script and the scanner:')
    yield Result(state=State.OK, notice=section.details)


register.agent_section(
    name="cve_2021_44228_log4j",
    parse_function=parse_cve_2021_44228_log4j,
)

register.check_plugin(
    name='cve_2021_44228_log4j',
    service_name='CVE-2021-44228-log4j',
    discovery_function=discovery_cve_2021_44228_log4j,
    check_function=check_cve_2021_44228_log4j,
    check_default_parameters={
        'files_vulnerable': (1, 1),
        'files_potential_vulnerable': (1, 1),
        'files_mitigated': (1, None),
        'files_scanned': {
            'lower': (None, None),
            'upper': (None, None),
        },
        'files_scanned_lower': (None, None),
        'files_skipped': (1, None),
        'errors': (None, 1),
        'directories_scanned': {
            'lower': (None, None),
            'upper': (None, None),
        },
        'directories_scanned_lower': (None, None),
        'run_time': (None, None),
        'items_on_info': [
            'files_vulnerable',
            'files_potential_vulnerable',
        ],
        'state_missing_output': 1,
        'ignore_missing_output': [
            'bakery_version',
            'script_version',
            'errors',
            'files_skipped',
        ],

    },
    check_ruleset_name='cve_2021_44228_log4j'
)

# #########################################################################################################
#
# Inventory for CVE scanner for log4j (CVE-2021-44228-log4j)
#
# #########################################################################################################


def inventory_inv_cve_2021_44228_log4j(params, section: CVE_2021_44228_log4j) -> InventoryResult:
    if params.get('do_not_inv_summary'):
        return

    path = ['software', 'cve_2021_44228_log4j', 'summary']

    key_columns = {'index': '1'}
    inventory_columns = {}
    status_columns = {}

    for key, value in [
        ('scanner_version', section.scanner_version),
        ('scan_options', section.scan_options),
        ('script_version', section.script_version),
        ('bakery_version', section.bakery_version),
    ]:
        if value is not None:
            inventory_columns.update({key: value})

    for key, value in [
        ('files_vulnerable', section.files_vulnerable),
        ('files_potential_vulnerable', section.files_potential_vulnerable),
        ('files_mitigated', section.files_mitigated),
        ('files_scanned', section.files_scanned),
        ('files_skipped', section.files_skipped),
        ('directories_scanned', section.directories_scanned),
        ('run_time', section.run_time),
        ('last_run', section.last_run),
        ('errors', section.errors),
    ]:
        if value is not None:
            status_columns.update({key: value})

    if not params.get('do_status_data'):
        inventory_columns.update(status_columns)
        status_columns = {}

    yield TableRow(
        path=path,
        key_columns=key_columns,
        inventory_columns=inventory_columns,
        status_columns=status_columns
    )


register.inventory_plugin(
    name='inv_cve_2021_44228_log4j',
    sections=['cve_2021_44228_log4j'],
    inventory_function=inventory_inv_cve_2021_44228_log4j,
    inventory_ruleset_name='inventory_cve_2021_44228_log4j',
    inventory_default_parameters={
        'do_status_data': False,
        'do_not_inv_summary': False
    },
)


# #########################################################################################################
#
# Inventory for CVE scanner for log4j (CVE-2021-44228-log4j)
#
# #########################################################################################################


def parse_inv_cve_2021_44228_log4j_report(string_table: StringTable):
    try:
        section = json.loads(string_table[0][0])
    except (json.decoder.JSONDecodeError, IndexError):
        section = None

    return section


register.agent_section(
    name="cve_2021_44228_log4j_report",
    parse_function=parse_inv_cve_2021_44228_log4j_report,
)


def inv_cve_2021_44228_log4j_report(params, section: Dict) -> InventoryResult:
    path = ['software', 'cve_2021_44228_log4j', 'report']
    index = 1

    for file in section.get('files', []):
        for report in file['reports']:
            key_columns = {'index': index}
            inventory_columns = {'path': file['path']}
            status_columns = report

            timestamp = status_columns['detected_at']  # 2022-01-11 20:06:41+0100, convert to ISO8601
            status_columns['time'] = f'{timestamp[:10]}T{timestamp[11:22]}:{timestamp[22:]}'  # 2022-01-11T20:06:41+01:00
            status_columns.pop('detected_at')
            status_columns['fixed'] = str(status_columns['fixed'])

            if not params.get('do_status_data'):
                inventory_columns.update(status_columns)
                status_columns = {}

            yield TableRow(
                path=path,
                key_columns=key_columns,
                inventory_columns=inventory_columns,
                status_columns=status_columns
            )
            index += 1

    if not params.get('do_not_inv_errors'):
        for error in section.get('errors', []):
            key_columns = {'index': index}
            inventory_columns = {'path': error['path']}

            status_columns = error
            status_columns.pop('path')

            timestamp = status_columns['created_at']  # 2022-01-11 20:06:41+0100, convert to ISO8601
            status_columns['time'] = f'{timestamp[:10]}T{timestamp[11:22]}:{timestamp[22:]}'  # 2022-01-11T20:06:41+01:00
            status_columns.pop('created_at')
            status_columns['status'] = 'ERROR'

            if not params.get('do_status_data'):
                inventory_columns.update(status_columns)
                status_columns = {}

            yield TableRow(
                path=path,
                key_columns=key_columns,
                inventory_columns=inventory_columns,
                status_columns=status_columns
            )
            index += 1


register.inventory_plugin(
    name='cve_2021_44228_log4j_report',
    inventory_function=inv_cve_2021_44228_log4j_report,
    inventory_ruleset_name='inventory_cve_2021_44228_log4j',
    inventory_default_parameters={
        'do_not_inv_errors': False,
        'do_status_data': False,
    },
)
